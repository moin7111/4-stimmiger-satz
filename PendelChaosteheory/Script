# Pendelphysik-Simulation - √úberarbeitete Version
# Wissenschaftliche Simulation von Einzel- und Doppelpendeln
# √úberarbeitete Benutzeroberfl√§che mit verbesserter Funktionalit√§t und wissenschaftlichem Design
#
# Features:
# - Physikalisch korrekte Simulation mit RK4-Integrator
# - Interaktive Parametersteuerung
# - Echtzeit-Visualisierung mit Spuren
# - Zeitbasierte Berechnungen und Markierungen
# - Responsive Benutzeroberfl√§che
# - Wissenschaftliches Design und Layout
#
# Verwendung:
# - Start/Stop: Simulation starten oder pausieren
# - Reset: Simulation auf Anfangszustand zur√ºcksetzen
# - Parameter: L√§ngen, Massen, D√§mpfung und Gravitation anpassen
# - Zeitsteuerung: Geschwindigkeit und automatische Stops
# - Berechnungen: Positionen zu bestimmten Zeitpunkten ermitteln
#
# Autor: √úberarbeitete Version f√ºr verbesserte Benutzerfreundlichkeit
# Datum: September 2025
#
# ---------------------------------------------------------------
import ui
import math
import time
import threading

# ---------- Physik: Doppelpendel-DGL (RK4) --------------------

def derivs(state, params):
    # state = [th1, w1, th2, w2]
    th1, w1, th2, w2 = state
    m1 = params['m1']; m2 = params['m2']
    l1 = params['l1']; l2 = params['l2']
    g = params['g']
    damping = params.get('damping', 0.0)

    delta = th2 - th1

    denom1 = (2*m1 + m2 - m2 * math.cos(2*th1 - 2*th2))
    denom2 = (2*m1 + m2 - m2 * math.cos(2*th1 - 2*th2))

    # avoid division by zero
    if abs(denom1) < 1e-6: denom1 = 1e-6
    if abs(denom2) < 1e-6: denom2 = 1e-6

    num1 = -g*(2*m1 + m2)*math.sin(th1)
    num1 += -m2*g*math.sin(th1 - 2*th2)
    num1 += -2*math.sin(delta)*m2*(w2*w2*l2 + w1*w1*l1*math.cos(delta))
    domega1 = num1 / (l1 * denom1)

    num2 = 2*math.sin(delta)*(w1*w1*l1*(m1+m2) + g*(m1+m2)*math.cos(th1) + w2*w2*l2*m2*math.cos(delta))
    domega2 = num2 / (l2 * denom2)

    # simple viscous damping on angular velocities
    if damping:
        domega1 -= damping * w1
        domega2 -= damping * w2

    return [w1, domega1, w2, domega2]


def rk4_step(state, dt, params):
    # classic RK4
    s1 = state
    k1 = derivs(s1, params)
    s2 = [s1[i] + 0.5*dt*k1[i] for i in range(4)]
    k2 = derivs(s2, params)
    s3 = [s1[i] + 0.5*dt*k2[i] for i in range(4)]
    k3 = derivs(s3, params)
    s4 = [s1[i] + dt*k3[i] for i in range(4)]
    k4 = derivs(s4, params)
    new = [s1[i] + dt*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6.0 for i in range(4)]
    return new

# Single pendulum special-case: set m2=0 effectively

# ---------- Hilfsfunktionen -----------------------------------

def polar_to_xy(origin, angle, length):
    x = origin[0] + length * math.sin(angle)
    y = origin[1] + length * math.cos(angle)
    return (x, y)


def xy_to_angle(origin, pt):
    dx = pt[0] - origin[0]
    dy = pt[1] - origin[1]
    # angle measured from vertical downwards (0 = down)
    angle = math.atan2(dx, dy)
    return angle

def draw_text_at(text, x, y, font=('Helvetica', 12)):
    # Helper: draw text at (x,y). Pythonista's ui.measure_string/draw_string do not support
    # number_of_lines in all versions, so we avoid that kwarg and handle simple multi-line text.
    if '\n' in text:
        # Render each line underneath the previous one
        lines = text.split('\n')
        line_height = ui.measure_string('Ag', font=font)[1]
        for idx, line in enumerate(lines):
            w, h = ui.measure_string(line, font=font)
            ui.draw_string(line, (x, y + idx * line_height, w, h), font=font)
    else:
        w, h = ui.measure_string(text, font=font)
        ui.draw_string(text, (x, y, w, h), font=font)

# ---------- Visual/Simulation View -----------------------------

class PendulumView(ui.View):
    def __init__(self, model):
        self.model = model
        self.background_color = 'white'
        self.set_needs_display()
        # for dragging
        self.dragging = None
        self._tap_candidate = False
        self._tap_start = 0.0
        # prepare double-buffer-like trail storage
        self.trail = []  # list of (x,y)
        # stamps: list of dicts with x,y,text
        self.stamps = []
        # callbacks (assigned by controller)
        self.cb_toggle = None
        self.cb_reset = None
        self.cb_change_mode = None
        self.cb_update_speed = None
        self.cb_update_damping = None
        self.cb_toggle_trail = None
        self.cb_clear_trail = None

        # build compact HUD overlay for small screens
        self._build_hud()

    def _build_hud(self):
        # Wissenschaftliches HUD mit strukturierter Anordnung
        hud = ui.View()
        hud.background_color = (0.95, 0.95, 0.98, 0.95)  # Heller, professioneller Hintergrund
        hud.corner_radius = 12
        hud.border_width = 1
        hud.border_color = (0.7, 0.7, 0.7, 0.3)
        hud.frame = (12, 12, 360, 180)
        hud.flex = 'RB'

        # Titel-Bereich
        title_label = ui.Label(frame=(8, 8, 344, 24))
        title_label.text = '‚öôÔ∏è Simulation Control'
        title_label.font = ('<System-Bold>', 14)
        title_label.text_color = (0.2, 0.2, 0.2)
        title_label.alignment = ui.ALIGN_CENTER
        hud.add_subview(title_label)

        y = 40

        # Simulationssteuerung - kompakt angeordnet
        control_row = ui.View(frame=(8, y, 344, 40))
        control_row.background_color = (0.9, 0.9, 0.95, 0.8)
        control_row.corner_radius = 8

        # Start/Stop Button
        self.btn_play = ui.Button(frame=(8, 8, 80, 28))
        self.btn_play.title = '‚ñ∂ Start'
        self.btn_play.font = ('<System>', 12)
        self.btn_play.corner_radius = 4
        self.btn_play.background_color = (0.2, 0.6, 0.2, 0.9)
        self.btn_play.action = lambda s: self.cb_toggle and self.cb_toggle(s)
        control_row.add_subview(self.btn_play)

        # Reset Button
        btn_reset = ui.Button(frame=(96, 8, 80, 28))
        btn_reset.title = '‚Üª Reset'
        btn_reset.font = ('<System>', 12)
        btn_reset.corner_radius = 4
        btn_reset.background_color = (0.6, 0.2, 0.2, 0.9)
        btn_reset.action = lambda s: self.cb_reset and self.cb_reset(s)
        control_row.add_subview(btn_reset)

        # Modus-Auswahl
        self.mode_seg_small = ui.SegmentedControl(frame=(184, 8, 152, 28))
        self.mode_seg_small.segments = ['Doppelpendel', 'Einfachpendel']
        self.mode_seg_small.selected_index = 0
        self.mode_seg_small.font = ('<System>', 11)
        self.mode_seg_small.action = lambda s: self.cb_change_mode and self.cb_change_mode(s)
        control_row.add_subview(self.mode_seg_small)

        hud.add_subview(control_row)
        y += 48

        # Parameter-Bereich
        param_row = ui.View(frame=(8, y, 344, 60))
        param_row.background_color = (0.9, 0.9, 0.95, 0.8)
        param_row.corner_radius = 8

        # Geschwindigkeit
        speed_label = ui.Label(frame=(8, 8, 80, 20))
        speed_label.text = 'Zeitlupe:'
        speed_label.font = ('<System>', 11)
        speed_label.text_color = (0.2, 0.2, 0.2)
        param_row.add_subview(speed_label)

        self.speed_val_lbl = ui.Label(frame=(280, 8, 56, 20))
        self.speed_val_lbl.alignment = ui.ALIGN_RIGHT
        self.speed_val_lbl.font = ('<System>', 11)
        self.speed_val_lbl.text = '1.00x'
        self.speed_val_lbl.text_color = (0.2, 0.2, 0.2)
        param_row.add_subview(self.speed_val_lbl)

        self.speed_slider_small = ui.Slider(frame=(90, 8, 190, 20))
        self.speed_slider_small.minimum_value = 0.05
        self.speed_slider_small.maximum_value = 3.0
        self.speed_slider_small.value = 1.0
        def on_speed(s):
            val = max(0.05, float(s.value))
            self.speed_val_lbl.text = '{:.2f}x'.format(val)
            if self.cb_update_speed:
                self.cb_update_speed(val)
        self.speed_slider_small.action = on_speed
        param_row.add_subview(self.speed_slider_small)

        # D√§mpfung
        damp_label = ui.Label(frame=(8, 34, 80, 20))
        damp_label.text = 'D√§mpfung:'
        damp_label.font = ('<System>', 11)
        damp_label.text_color = (0.2, 0.2, 0.2)
        param_row.add_subview(damp_label)

        self.damp_val_lbl = ui.Label(frame=(280, 34, 56, 20))
        self.damp_val_lbl.alignment = ui.ALIGN_RIGHT
        self.damp_val_lbl.font = ('<System>', 11)
        self.damp_val_lbl.text = '0.00'
        self.damp_val_lbl.text_color = (0.2, 0.2, 0.2)
        param_row.add_subview(self.damp_val_lbl)

        self.damp_slider = ui.Slider(frame=(90, 34, 190, 20))
        self.damp_slider.minimum_value = 0.0
        self.damp_slider.maximum_value = 0.1
        self.damp_slider.value = 0.0
        def on_damp(s):
            val = max(0.0, float(s.value))
            self.damp_val_lbl.text = '{:.2f}'.format(val)
            if self.cb_update_damping:
                self.cb_update_damping(val)
        self.damp_slider.action = on_damp
        param_row.add_subview(self.damp_slider)

        hud.add_subview(param_row)
        y += 68

        # Visualisierung-Steuerung
        vis_row = ui.View(frame=(8, y, 344, 40))
        vis_row.background_color = (0.9, 0.9, 0.95, 0.8)
        vis_row.corner_radius = 8

        # Spur aktivieren
        trail_label = ui.Label(frame=(8, 8, 80, 24))
        trail_label.text = 'üìä Spur:'
        trail_label.font = ('<System>', 12)
        trail_label.text_color = (0.2, 0.2, 0.2)
        vis_row.add_subview(trail_label)

        self.trail_switch = ui.Switch(frame=(90, 8, 56, 24))
        self.trail_switch.value = True
        self.trail_switch.action = lambda s: self.cb_toggle_trail and self.cb_toggle_trail(bool(s.value))
        vis_row.add_subview(self.trail_switch)

        # Spur l√∂schen Button
        btn_clear = ui.Button(frame=(160, 8, 80, 24))
        btn_clear.title = 'üóëÔ∏è L√∂schen'
        btn_clear.font = ('<System>', 11)
        btn_clear.corner_radius = 4
        btn_clear.background_color = (0.6, 0.6, 0.6, 0.9)
        btn_clear.action = lambda s: self.cb_clear_trail and self.cb_clear_trail()
        vis_row.add_subview(btn_clear)

        hud.add_subview(vis_row)

        self.add_subview(hud)
        self.hud = hud

    def set_playing(self, playing):
        self.btn_play.title = '‚è∏Ô∏è Pause' if playing else '‚ñ∂ Start'

    def draw(self):
        # drawing callback - wissenschaftliches Design
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15  # pivot near top
        origin = (cx, cy)

        # Hintergrund mit Gradient-Effekt f√ºr wissenschaftlichen Look
        ui.set_color((0.95, 0.97, 0.99, 1.0))
        ui.Path.rect(0, 0, r.w, r.h).fill()

        # Gitter-Linien f√ºr wissenschaftliche Pr√§zision
        ui.set_color((0.8, 0.8, 0.8, 0.3))
        grid_spacing = 50
        for x in range(0, int(r.w), grid_spacing):
            ui.Path().move_to(x, 0).line_to(x, r.h).stroke()
        for y in range(0, int(r.h), grid_spacing):
            ui.Path().move_to(0, y).line_to(r.w, y).stroke()

        # compute bob positions from model state
        th1, w1, th2, w2 = self.model.state
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter

        x1, y1 = polar_to_xy(origin, th1, l1)
        x2, y2 = polar_to_xy((x1,y1), th2, l2)

        # draw trails (for second bob) - verbesserter Effekt
        if self.trail:
            path = ui.Path()
            path.move_to(self.trail[0][0], self.trail[0][1])
            for i, (tx, ty) in enumerate(self.trail[1:]):
                alpha = max(0.05, 0.3 * (1 - i / len(self.trail)))
                ui.set_color((0.2, 0.4, 0.8, alpha))
                path.line_to(tx, ty)
            path.stroke()

        # rods - mit physikalischer Darstellung
        ui.set_color((0.3, 0.3, 0.3, 1.0))
        ui.set_line_width(3)

        p = ui.Path()
        p.move_to(origin[0], origin[1])
        p.line_to(x1, y1)
        p.stroke()

        p2 = ui.Path()
        p2.move_to(x1, y1)
        p2.line_to(x2, y2)
        p2.stroke()

        # bobs - wissenschaftliche Darstellung
        r1 = 16
        r2 = 14

        # Erste Masse (gr√∂√üer)
        ui.set_color((0.2, 0.5, 0.8, 0.9))
        ui.Path.oval(x1-r1, y1-r1, r1*2, r1*2).fill()
        ui.set_color((0.1, 0.3, 0.6, 1.0))
        ui.Path.oval(x1-r1, y1-r1, r1*2, r1*2).stroke()

        # Zweite Masse (kleiner)
        ui.set_color((0.8, 0.2, 0.3, 0.9))
        ui.Path.oval(x2-r2, y2-r2, r2*2, r2*2).fill()
        ui.set_color((0.6, 0.1, 0.2, 1.0))
        ui.Path.oval(x2-r2, y2-r2, r2*2, r2*2).stroke()

        # show pivot - Aufh√§ngungspunkt
        ui.set_color((0.2, 0.2, 0.2, 1.0))
        ui.set_line_width(2)
        ui.Path.oval(origin[0]-6, origin[1]-6, 12, 12).fill()
        ui.set_color((0.4, 0.4, 0.4, 1.0))
        ui.Path.oval(origin[0]-6, origin[1]-6, 12, 12).stroke()

        # draw stamps - Zeitmarkierungen
        ui.set_color((0.1, 0.4, 0.8, 0.8))
        for s in self.stamps:
            ui.set_line_width(2)
            ui.Path.oval(s['x']-6, s['y']-6, 12, 12).stroke()
            draw_text_at(s['text'], s['x']+10, s['y']-10, font=('Helvetica', 11))

        # Zeit-Anzeige - verbessert
        ui.set_color((0.2, 0.2, 0.2, 1.0))

        # Hintergrund f√ºr Zeit-Anzeige
        time_bg = ui.Path()
        time_bg.move_to(8, r.h - 50 + 6)
        time_bg.line_to(8, r.h - 50)
        time_bg.line_to(208, r.h - 50)
        time_bg.line_to(208, r.h - 10)
        time_bg.line_to(8, r.h - 10)
        time_bg.close()
        ui.set_color((1, 1, 1, 0.9))
        time_bg.fill()
        ui.set_color((0.7, 0.7, 0.7, 0.5))
        time_bg.stroke()

        # Zeit-Text
        tlabel = '‚è±Ô∏è t = {:.3f} s'.format(self.model.sim_time)
        draw_text_at(tlabel, 18, r.h - 42, font=('Helvetica-Bold', 14))

        # Simulationsstatus
        status_text = '‚ñ∂ L√§uft' if self.model.running else '‚è∏Ô∏è Pausiert'
        status_color = (0.2, 0.7, 0.2, 1.0) if self.model.running else (0.7, 0.2, 0.2, 1.0)
        draw_text_at(status_text, r.w - 120, r.h - 42, font=('Helvetica', 12))

    # Touch handling: allow dragging of first or second bob to set start angles
    def touch_began(self, touch):
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        th1, w1, th2, w2 = self.model.state
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter
        x1, y1 = polar_to_xy(origin, th1, l1)
        x2, y2 = polar_to_xy((x1,y1), th2, l2)

        tx, ty = touch.location
        if (tx-x2)**2 + (ty-y2)**2 < 20*20:
            self.dragging = 'bob2'
        elif (tx-x1)**2 + (ty-y1)**2 < 20*20:
            self.dragging = 'bob1'
        else:
            self.dragging = None
            self._tap_candidate = True
            try:
                self._tap_start = touch.timestamp
            except Exception:
                self._tap_start = time.time()

    def touch_moved(self, touch):
        if not self.dragging:
            # if finger moves too far, cancel tap candidate
            try:
                px, py = touch.prev_location
            except Exception:
                px, py = touch.location
            dx = touch.location[0] - px
            dy = touch.location[1] - py
            if dx*dx + dy*dy > 36:
                self._tap_candidate = False
            return
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        tx, ty = touch.location

        if self.dragging == 'bob1':
            # set th1 from origin->touch
            th1 = xy_to_angle(origin, (tx,ty))
            # update state angles, zero velocities
            self.model.state[0] = th1
            self.model.state[1] = 0.0
            # also update second bob position to keep geometry (keep current th2)
            self.set_needs_display()
        elif self.dragging == 'bob2':
            # compute angle of second relative to first bob's position
            th1 = self.model.state[0]
            l1 = self.model.params['l1'] * self.model.pixels_per_meter
            x1, y1 = polar_to_xy(origin, th1, l1)
            th2 = xy_to_angle((x1,y1), (tx,ty))
            self.model.state[2] = th2
            self.model.state[3] = 0.0
            self.set_needs_display()

    def touch_ended(self, touch):
        if self.dragging:
            self.dragging = None
            return
        # toggle play/pause on simple tap
        if self._tap_candidate:
            self._tap_candidate = False
            if self.cb_toggle:
                self.cb_toggle(self)
        self.dragging = None

    # hooks from controller
    def attach_callbacks(self, *, on_toggle, on_reset, on_change_mode, on_speed, on_damping, on_toggle_trail, on_clear_trail):
        self.cb_toggle = on_toggle
        self.cb_reset = on_reset
        self.cb_change_mode = on_change_mode
        self.cb_update_speed = on_speed
        self.cb_update_damping = on_damping
        self.cb_toggle_trail = on_toggle_trail
        self.cb_clear_trail = on_clear_trail

        # sync HUD initial values
        self.speed_slider_small.value = getattr(self, 'speed_slider_small', self.speed_slider_small).value
        self.speed_val_lbl.text = '{:.2f}x'.format(1.0)
        self.damp_slider.value = 0.0
        self.damp_val_lbl.text = '0.00'

# ---------- Model (zustand + simulation-loop) ------------------

class PendulumModel(object):
    def __init__(self):
        # physical parameters (SI units)
        self.params = {
            'm1': 1.0,
            'm2': 1.0,
            'l1': 1.0,   # meters
            'l2': 1.0,
            'g': 9.81,
            'damping': 0.0
        }
        # initial state: theta measured from vertical (downwards)
        self.state = [math.radians(120), 0.0, math.radians(-10), 0.0]
        self.sim_time = 0.0
        self.running = False
        self.time_scale = 1.0  # speed multiplier
        self.dt = 0.01  # base timestep for integrator
        self.pixels_per_meter = 180.0  # scaling for drawing
        self.trail_max = 400
        self.trail = []
        self.trail_enabled = True
        self.stop_at = None  # if set, simulation will stop at this sim_time

    def step(self, dt):
        # advance by dt (already includes time_scale externally)
        self.state = rk4_step(self.state, dt, self.params)
        self.sim_time += dt

    def reset(self):
        self.state = [math.radians(120), 0.0, math.radians(-10), 0.0]
        self.sim_time = 0.0
        self.trail = []
        self.stop_at = None

    def single_step_silent(self, t):
        # compute state at time t from initial state (used for stamping positions at specific times)
        # integrate from t0=0 to t in a local copy so we don't disturb running sim
        s = [math.radians(120), 0.0, math.radians(-10), 0.0]
        params = self.params.copy()
        dt = 0.005
        steps = max(1, int(abs(t) / dt))
        dt = t / steps
        for i in range(steps):
            s = rk4_step(s, dt, params)
        return s

# ---------- Controller / App ----------------------------------

class PendulumApp(object):
    def __init__(self):
        self.model = PendulumModel()
        # root view with responsive layout
        self.view = ui.View()
        self.view.name = 'Doppelpendel ‚Äî Demo'
        self.view.background_color = 'white'
        self.setup_layout()
        self.running = False
        # periodic timer
        self.timer = None

    def setup_layout(self):
        # Moderne, strukturierte Layout-Gestaltung
        self.draw_view = PendulumView(self.model)
        self.draw_view.frame = (0, 0, 700, 700)
        self.draw_view.flex = 'WH'
        self.view.add_subview(self.draw_view)

        # Kontrollbereich - rechts oder unten je nach Bildschirmgr√∂√üe
        ctrl_width = 340
        ctrl = ui.View(frame=(700, 0, ctrl_width, 700))
        ctrl.flex = 'WH'
        ctrl.background_color = (0.98, 0.98, 0.99, 0.95)

        # Hintergrund mit Rahmen f√ºr wissenschaftlichen Look
        bg_view = ui.View(frame=(0, 0, ctrl_width, 700))
        bg_view.background_color = (0.95, 0.97, 0.99, 0.8)
        bg_view.corner_radius = 8
        bg_view.border_width = 1
        bg_view.border_color = (0.8, 0.8, 0.8, 0.5)
        ctrl.add_subview(bg_view)

        y = 20

        def create_section_header(title, icon="üî¨"):
            nonlocal y
            header_view = ui.View(frame=(10, y, ctrl_width-20, 40))
            header_view.background_color = (0.3, 0.5, 0.8, 0.1)
            header_view.corner_radius = 6

            title_label = ui.Label(frame=(10, 8, 200, 24))
            title_label.text = f"{icon} {title}"
            title_label.font = ('<System-Bold>', 16)
            title_label.text_color = (0.1, 0.3, 0.6)
            header_view.add_subview(title_label)

            ctrl.add_subview(header_view)
            y += 48
            return y

        def add_control_group(title, controls_func):
            nonlocal y
            # Gruppe mit Rahmen
            group_view = ui.View(frame=(10, y, ctrl_width-20, 60))
            group_view.background_color = (1, 1, 1, 0.7)
            group_view.corner_radius = 6
            group_view.border_width = 1
            group_view.border_color = (0.8, 0.8, 0.8, 0.4)

            # Gruppentitel
            title_label = ui.Label(frame=(10, 5, 200, 20))
            title_label.text = title
            title_label.font = ('<System>', 12)
            title_label.text_color = (0.3, 0.3, 0.3)
            group_view.add_subview(title_label)

            # Controls hinzuf√ºgen
            controls_func(group_view, 30)

            ctrl.add_subview(group_view)
            y += 70
            return y

        # Hauptsteuerung
        create_section_header("Simulation Control", "üéõÔ∏è")

        def main_controls(group_view, content_y):
            # Start/Stop Button
            self.btn_run = ui.Button(frame=(10, content_y, 100, 36))
            self.btn_run.title = '‚ñ∂ Start'
            self.btn_run.font = ('<System>', 13)
            self.btn_run.corner_radius = 6
            self.btn_run.background_color = (0.2, 0.7, 0.3, 0.9)
            self.btn_run.action = self.toggle_run
            group_view.add_subview(self.btn_run)

            # Reset Button
            btn_reset = ui.Button(frame=(120, content_y, 100, 36))
            btn_reset.title = '‚Üª Reset'
            btn_reset.font = ('<System>', 13)
            btn_reset.corner_radius = 6
            btn_reset.background_color = (0.7, 0.2, 0.2, 0.9)
            btn_reset.action = lambda sender: self.reset()
            group_view.add_subview(btn_reset)

            # Modus-Auswahl
            self.mode_seg = ui.SegmentedControl(frame=(10, content_y+44, ctrl_width-40, 36))
            self.mode_seg.segments = ['Doppelpendel', 'Einfachpendel']
            self.mode_seg.selected_index = 0
            self.mode_seg.font = ('<System>', 12)
            self.mode_seg.action = self.change_mode
            group_view.add_subview(self.mode_seg)

        add_control_group("Hauptsteuerung", main_controls)

        # Physikalische Parameter
        create_section_header("Physikalische Parameter", "‚öñÔ∏è")

        def physics_controls(group_view, content_y):
            # L√§ngen-Parameter
            l1_label = ui.Label(frame=(10, content_y, 120, 20))
            l1_label.text = 'L√§nge 1 (m):'
            l1_label.font = ('<System>', 11)
            group_view.add_subview(l1_label)

            self.l1_field = ui.TextField(frame=(140, content_y, 80, 20))
            self.l1_field.text = '1.0'
            self.l1_field.font = ('<System>', 11)
            group_view.add_subview(self.l1_field)

            l2_label = ui.Label(frame=(10, content_y+26, 120, 20))
            l2_label.text = 'L√§nge 2 (m):'
            l2_label.font = ('<System>', 11)
            group_view.add_subview(l2_label)

            self.l2_field = ui.TextField(frame=(140, content_y+26, 80, 20))
            self.l2_field.text = '1.0'
            self.l2_field.font = ('<System>', 11)
            group_view.add_subview(self.l2_field)

            # Massen-Parameter
            m1_label = ui.Label(frame=(230, content_y, 80, 20))
            m1_label.text = 'Masse 1 (kg):'
            m1_label.font = ('<System>', 11)
            group_view.add_subview(m1_label)

            self.m1_field = ui.TextField(frame=(320, content_y, 80, 20))
            self.m1_field.text = '1.0'
            self.m1_field.font = ('<System>', 11)
            group_view.add_subview(self.m1_field)

            m2_label = ui.Label(frame=(230, content_y+26, 80, 20))
            m2_label.text = 'Masse 2 (kg):'
            m2_label.font = ('<System>', 11)
            group_view.add_subview(m2_label)

            self.m2_field = ui.TextField(frame=(320, content_y+26, 80, 20))
            self.m2_field.text = '1.0'
            self.m2_field.font = ('<System>', 11)
            group_view.add_subview(self.m2_field)

        add_control_group("Pendel-Parameter", physics_controls)

        # Simulationsparameter
        create_section_header("Simulations-Einstellungen", "‚öôÔ∏è")

        def sim_controls(group_view, content_y):
            # Zeit-Skalierung
            speed_label = ui.Label(frame=(10, content_y, 120, 20))
            speed_label.text = 'Zeitlupe:'
            speed_label.font = ('<System>', 11)
            group_view.add_subview(speed_label)

            self.speed_slider = ui.Slider(frame=(140, content_y, 180, 20))
            self.speed_slider.minimum_value = 0.05
            self.speed_slider.maximum_value = 3.0
            self.speed_slider.value = 1.0
            self.speed_slider.action = lambda s: self.update_speed_value(float(s.value))
            group_view.add_subview(self.speed_slider)

            self.speed_label = ui.Label(frame=(325, content_y, 50, 20))
            self.speed_label.text = '1.00x'
            self.speed_label.font = ('<System>', 11)
            self.speed_label.alignment = ui.ALIGN_RIGHT
            group_view.add_subview(self.speed_label)

            # D√§mpfung
            damp_label = ui.Label(frame=(10, content_y+26, 120, 20))
            damp_label.text = 'D√§mpfung:'
            damp_label.font = ('<System>', 11)
            group_view.add_subview(damp_label)

            self.damping_slider = ui.Slider(frame=(140, content_y+26, 180, 20))
            self.damping_slider.minimum_value = 0.0
            self.damping_slider.maximum_value = 0.1
            self.damping_slider.value = 0.0
            self.damping_slider.action = lambda s: self.update_damping(float(s.value))
            group_view.add_subview(self.damping_slider)

            self.damping_label = ui.Label(frame=(325, content_y+26, 50, 20))
            self.damping_label.text = '0.00'
            self.damping_label.font = ('<System>', 11)
            self.damping_label.alignment = ui.ALIGN_RIGHT
            group_view.add_subview(self.damping_label)

        add_control_group("Simulationsparameter", sim_controls)

        # Visualisierung
        create_section_header("Visualisierung", "üìä")

        def vis_controls(group_view, content_y):
            # Spur-Steuerung
            trail_label = ui.Label(frame=(10, content_y, 80, 24))
            trail_label.text = 'Spur aktiv:'
            trail_label.font = ('<System>', 12)
            group_view.add_subview(trail_label)

            trail_switch = ui.Switch(frame=(100, content_y, 56, 24))
            trail_switch.value = True
            trail_switch.action = lambda s: self.toggle_trail(bool(s.value))
            group_view.add_subview(trail_switch)

            btn_clear = ui.Button(frame=(170, content_y, 100, 24))
            btn_clear.title = 'üóëÔ∏è L√∂schen'
            btn_clear.font = ('<System>', 11)
            btn_clear.corner_radius = 4
            btn_clear.background_color = (0.6, 0.6, 0.6, 0.9)
            btn_clear.action = lambda s: self.clear_trail()
            group_view.add_subview(btn_clear)

        add_control_group("Spur-Steuerung", vis_controls)

        # Zeitsteuerung
        create_section_header("Zeitsteuerung", "‚è∞")

        def time_controls(group_view, content_y):
            # Automatisches Stoppen
            stop_label = ui.Label(frame=(10, content_y, 200, 20))
            stop_label.text = 'Stop bei t ='
            stop_label.font = ('<System>', 11)
            group_view.add_subview(stop_label)

            self.stop_field = ui.TextField(frame=(140, content_y, 100, 20))
            self.stop_field.placeholder = 'z.B. 12.5'
            self.stop_field.font = ('<System>', 11)
            group_view.add_subview(self.stop_field)

            btn_setstop = ui.Button(frame=(250, content_y, 80, 20))
            btn_setstop.title = 'Setzen'
            btn_setstop.font = ('<System>', 11)
            btn_setstop.corner_radius = 4
            btn_setstop.action = self.set_stop_time
            group_view.add_subview(btn_setstop)

            # Position berechnen
            calc_label = ui.Label(frame=(10, content_y+26, 200, 20))
            calc_label.text = 'Position bei t ='
            calc_label.font = ('<System>', 11)
            group_view.add_subview(calc_label)

            self.compute_field = ui.TextField(frame=(140, content_y+26, 100, 20))
            self.compute_field.placeholder = 'z.B. 3.14'
            self.compute_field.font = ('<System>', 11)
            group_view.add_subview(self.compute_field)

            btn_compute = ui.Button(frame=(250, content_y+26, 80, 20))
            btn_compute.title = 'Berechnen'
            btn_compute.font = ('<System>', 11)
            btn_compute.corner_radius = 4
            btn_compute.background_color = (0.2, 0.4, 0.8, 0.9)
            btn_compute.action = self.compute_and_stamp
            group_view.add_subview(btn_compute)

        add_control_group("Zeitfunktionen", time_controls)

        # Ergebnisse
        create_section_header("Ergebnisse & Markierungen", "üìã")

        def results_controls(group_view, content_y):
            self.stamps_label = ui.TextView(frame=(10, content_y, ctrl_width-40, 120))
            self.stamps_label.editable = False
            self.stamps_label.font = ('<System>', 11)
            self.stamps_label.background_color = (0.98, 0.98, 0.98, 0.8)
            self.stamps_label.corner_radius = 4
            group_view.add_subview(self.stamps_label)

        add_control_group("Zeitmarkierungen", results_controls)

        self.view.add_subview(ctrl)
        self.ctrl = ctrl

        # connect HUD callbacks to controller methods
        self.draw_view.attach_callbacks(
            on_toggle=self.toggle_run,
            on_reset=lambda s: self.reset(),
            on_change_mode=self.change_mode,
            on_speed=self.update_speed_value,
            on_damping=self.update_damping,
            on_toggle_trail=self.toggle_trail,
            on_clear_trail=self.clear_trail,
        )

        # Initiale Werte synchronisieren
        self.update_speed_value(1.0)
        self.update_damping(0.0)

        # Modus synchronisieren
        if hasattr(self, 'mode_seg'):
            self.mode_seg.selected_index = 0

        # ensure initial layout fits the screen
        self.view.layout = self._layout_root
        self._layout_root()

    # Control callbacks
    def toggle_run(self, sender):
        if self.model.running:
            self.pause()
        else:
            self.start()

    def start(self):
        if self.model.running:
            return
        self.model.running = True
        self.btn_run.title = '‚è∏Ô∏è Pause'
        self._start_timer()
        self.draw_view.set_playing(True)

    def pause(self):
        self.model.running = False
        self.btn_run.title = '‚ñ∂ Start'
        self._stop_timer()
        self.draw_view.set_playing(False)

    def reset(self):
        self.model.reset()
        self.draw_view.trail = []
        self.draw_view.stamps = []
        self.stamps_label.text = ''
        self.draw_view.set_needs_display()

    def change_mode(self, sender):
        # Synchronisiere Modus zwischen HUD und Hauptsteuerung
        if hasattr(self, 'mode_seg'):
            self.mode_seg.selected_index = sender.selected_index

        if sender.selected_index == 1:
            # Einfachpendel -> set m2=0 to reduce to single pendulum
            self.model.params['m2'] = 0.0
        else:
            # Doppelpendel
            self.model.params['m2'] = 1.0

    def update_speed_value(self, val):
        val = max(0.05, float(val))
        self.model.time_scale = val
        # Update Labels in both main UI and HUD
        if hasattr(self, 'speed_label'):
            self.speed_label.text = '{:.2f}x'.format(val)
        if hasattr(self, 'speed_val_lbl'):
            self.speed_val_lbl.text = '{:.2f}x'.format(val)

    def update_trail(self, sender):
        self.model.trail_max = int(sender.value)

    def update_damping(self, val):
        val = max(0.0, float(val))
        self.model.params['damping'] = val
        # Update Labels in both main UI and HUD
        if hasattr(self, 'damping_label'):
            self.damping_label.text = '{:.2f}'.format(val)
        if hasattr(self, 'damp_val_lbl'):
            self.damp_val_lbl.text = '{:.2f}'.format(val)

    def toggle_trail(self, enabled):
        self.model.trail_enabled = bool(enabled)
        if not enabled:
            self.clear_trail()

    def clear_trail(self):
        self.draw_view.trail = []
        self.draw_view.set_needs_display()

    def set_stop_time(self, sender):
        try:
            v = float(self.stop_field.text)
            if v <= 0:
                self.model.stop_at = None
            else:
                self.model.stop_at = v
        except Exception:
            self.model.stop_at = None

    def compute_and_stamp(self, sender):
        # compute state at given time (from initial state) and stamp on the scene
        try:
            t = float(self.compute_field.text)
        except Exception:
            return
        s = self.model.single_step_silent(t)
        # convert to pixel coordinates
        r = self.draw_view.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter
        x1, y1 = polar_to_xy(origin, s[0], l1)
        x2, y2 = polar_to_xy((x1,y1), s[2], l2)
        text = 't={:.3f}s\n({:.4f},{:.4f})'.format(t, x2/self.model.pixels_per_meter, y2/self.model.pixels_per_meter)
        # add stamp
        stamp = {'x': x2, 'y': y2, 'text': text}
        self.draw_view.stamps.append(stamp)
        # update textual stamps
        prev = self.stamps_label.text
        entry = 't={:.3f}s -> x={:.4f} m, y={:.4f} m\n'.format(t, x2/self.model.pixels_per_meter, y2/self.model.pixels_per_meter)
        self.stamps_label.text = entry + prev
        self.draw_view.set_needs_display()

    # Timer management
    def _start_timer(self):
        # run update loop in background thread to not block UI
        if self.timer:
            return
        self._timer_stop = False
        def loop():
            last = time.time()
            while self.model.running and not self._timer_stop:
                now = time.time()
                real_dt = now - last
                last = now
                # scaled dt
                dt = real_dt * self.model.time_scale
                # clamp dt so integrator remains stable
                steps = max(1, int(dt / self.model.dt))
                small_dt = dt / steps
                for i in range(steps):
                    self.model.step(small_dt)
                # update trail with second bob position
                r = self.draw_view.bounds
                cx = r.w * 0.5
                cy = r.h * 0.15
                origin = (cx, cy)
                l1 = self.model.params['l1'] * self.model.pixels_per_meter
                l2 = self.model.params['l2'] * self.model.pixels_per_meter
                x1, y1 = polar_to_xy(origin, self.model.state[0], l1)
                x2, y2 = polar_to_xy((x1,y1), self.model.state[2], l2)
                if self.model.trail_enabled:
                    self.draw_view.trail.append((x2,y2))
                    if len(self.draw_view.trail) > self.model.trail_max:
                        self.draw_view.trail.pop(0)
                    # copy trail to view for drawing
                    self.draw_view.trail = list(self.draw_view.trail)

                # check stop condition
                if self.model.stop_at is not None and self.model.sim_time >= self.model.stop_at:
                    # automatically pause
                    self.pause()
                    break

                # request redraw on main thread
                ui.delay(self.draw_view.set_needs_display, 0)
                # sleep a small amount
                time.sleep(0.016)  # ~60 Hz
        t = threading.Thread(target=loop)
        t.daemon = True
        t.start()
        self.timer = t

    def _stop_timer(self):
        self._timer_stop = True
        self.timer = None

    def present(self):
        # present the assembled UI
        self.view.present('fullscreen', hide_title_bar=True)

    # responsive layout for root view
    def _layout_root(self, *args, **kwargs):
        r = self.view.bounds
        total_w = r.w
        total_h = r.h
        ctrl_w = 320
        spacing = 0
        if total_w >= 980:
            # two columns
            self.draw_view.frame = (0, 0, total_w - ctrl_w - spacing, total_h)
            self.ctrl.frame = (total_w - ctrl_w, 0, ctrl_w, total_h)
        else:
            # stacked, controls below
            ctrl_h = min(360, total_h * 0.42)
            self.draw_view.frame = (0, 0, total_w, total_h - ctrl_h - spacing)
            self.ctrl.frame = (0, total_h - ctrl_h, total_w, ctrl_h)


# Run the app
if __name__ == '__main__':
    app = PendulumApp()
    app.present()
