# Doppelpendel_Pythonista_Concept.py
# Pythonista-ready script (iPad) — Konzept + funktionsfähiger Prototyp
# Ziel: interaktive, "natürliche" Simulation von Pendel und Doppelpendel
# Features:
# - Einzel- und Doppelpendel-Modus
# - RK4-Integrator für stabile Numerik
# - Touch: Bob ziehen zum Setzen des Startorts
# - Zeit-Skalierung (Geschwindigkeit erhöhen/verringern)
# - Spur (Trail) des letzten Schwingpunkts
# - Laufende Zeit, Stopp bei vordefiniertem Zeitpunkt
# - Positionen für bestimmte Zeiten berechnen & als Zeitstempel auf die Szene zeichnen
# - Werte werden mit reduziertem Zahlenformat (4 Dezimalstellen) angezeigt
#
# Hinweise zum Ausführen:
# - In Pythonista öffnen und ausführen.
# - Die UI ist mit dem ui-Modul aufgebaut; das Zeichenfeld ist links, Controls rechts.
#
# ---------------------------------------------------------------
import ui
import math
import time
import threading

# ---------- Physik: Doppelpendel-DGL (RK4) --------------------

def derivs(state, params):
    # state = [th1, w1, th2, w2]
    th1, w1, th2, w2 = state
    m1 = params['m1']; m2 = params['m2']
    l1 = params['l1']; l2 = params['l2']
    g = params['g']
    damping = params.get('damping', 0.0)

    delta = th2 - th1

    denom1 = (2*m1 + m2 - m2 * math.cos(2*th1 - 2*th2))
    denom2 = (2*m1 + m2 - m2 * math.cos(2*th1 - 2*th2))

    # avoid division by zero
    if abs(denom1) < 1e-6: denom1 = 1e-6
    if abs(denom2) < 1e-6: denom2 = 1e-6

    num1 = -g*(2*m1 + m2)*math.sin(th1)
    num1 += -m2*g*math.sin(th1 - 2*th2)
    num1 += -2*math.sin(delta)*m2*(w2*w2*l2 + w1*w1*l1*math.cos(delta))
    domega1 = num1 / (l1 * denom1)

    num2 = 2*math.sin(delta)*(w1*w1*l1*(m1+m2) + g*(m1+m2)*math.cos(th1) + w2*w2*l2*m2*math.cos(delta))
    domega2 = num2 / (l2 * denom2)

    # simple viscous damping on angular velocities
    if damping:
        domega1 -= damping * w1
        domega2 -= damping * w2

    return [w1, domega1, w2, domega2]


def rk4_step(state, dt, params):
    # classic RK4
    s1 = state
    k1 = derivs(s1, params)
    s2 = [s1[i] + 0.5*dt*k1[i] for i in range(4)]
    k2 = derivs(s2, params)
    s3 = [s1[i] + 0.5*dt*k2[i] for i in range(4)]
    k3 = derivs(s3, params)
    s4 = [s1[i] + dt*k3[i] for i in range(4)]
    k4 = derivs(s4, params)
    new = [s1[i] + dt*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i])/6.0 for i in range(4)]
    return new

# Single pendulum special-case: set m2=0 effectively

# ---------- Hilfsfunktionen -----------------------------------

def polar_to_xy(origin, angle, length):
    x = origin[0] + length * math.sin(angle)
    y = origin[1] + length * math.cos(angle)
    return (x, y)


def xy_to_angle(origin, pt):
    dx = pt[0] - origin[0]
    dy = pt[1] - origin[1]
    # angle measured from vertical downwards (0 = down)
    angle = math.atan2(dx, dy)
    return angle

def draw_text_at(text, x, y, font=('Helvetica', 12)):
    # Helper: draw text at (x,y). Pythonista's ui.measure_string/draw_string do not support
    # number_of_lines in all versions, so we avoid that kwarg and handle simple multi-line text.
    if '\n' in text:
        # Render each line underneath the previous one
        lines = text.split('\n')
        line_height = ui.measure_string('Ag', font=font)[1]
        for idx, line in enumerate(lines):
            w, h = ui.measure_string(line, font=font)
            ui.draw_string(line, (x, y + idx * line_height, w, h), font=font)
    else:
        w, h = ui.measure_string(text, font=font)
        ui.draw_string(text, (x, y, w, h), font=font)

# ---------- Visual/Simulation View -----------------------------

class PendulumView(ui.View):
    def __init__(self, model):
        self.model = model
        self.background_color = 'white'
        self.set_needs_display()
        # for dragging
        self.dragging = None
        self._tap_candidate = False
        self._tap_start = 0.0
        # prepare double-buffer-like trail storage
        self.trail = []  # list of (x,y)
        # stamps: list of dicts with x,y,text
        self.stamps = []
        # callbacks (assigned by controller)
        self.cb_toggle = None
        self.cb_reset = None
        self.cb_change_mode = None
        self.cb_update_speed = None
        self.cb_update_damping = None
        self.cb_toggle_trail = None
        self.cb_clear_trail = None

        # build compact HUD overlay for small screens
        self._build_hud()

    def _build_hud(self):
        hud = ui.View()
        hud.background_color = (1,1,1,0.85)
        hud.corner_radius = 10
        hud.frame = (12, 12, 320, 148)
        hud.flex = 'RB'

        y = 8
        # row 1: Start/Pause + Reset + Mode
        self.btn_play = ui.Button(frame=(8,y,92,32))
        self.btn_play.title = 'Start'
        self.btn_play.action = lambda s: self.cb_toggle and self.cb_toggle(s)
        hud.add_subview(self.btn_play)

        btn_reset = ui.Button(frame=(108,y,92,32))
        btn_reset.title = 'Reset'
        btn_reset.action = lambda s: self.cb_reset and self.cb_reset(s)
        hud.add_subview(btn_reset)

        self.mode_seg_small = ui.SegmentedControl(frame=(208,y,104,32))
        self.mode_seg_small.segments = ['Double','Single']
        self.mode_seg_small.selected_index = 0
        self.mode_seg_small.action = lambda s: self.cb_change_mode and self.cb_change_mode(s)
        hud.add_subview(self.mode_seg_small)
        y += 36

        # row 2: Speed
        lbl_speed = ui.Label(frame=(8,y,60,22))
        lbl_speed.text = 'Speed'
        lbl_speed.font = ('<System>', 12)
        hud.add_subview(lbl_speed)

        self.speed_val_lbl = ui.Label(frame=(268,y,44,22))
        self.speed_val_lbl.alignment = ui.ALIGN_RIGHT
        self.speed_val_lbl.font = ('<System>', 12)
        self.speed_val_lbl.text = '1.00x'
        hud.add_subview(self.speed_val_lbl)

        self.speed_slider_small = ui.Slider(frame=(66,y,198,22))
        # Map to [0.05, 3.0]
        self.speed_slider_small.minimum_value = 0.05
        self.speed_slider_small.maximum_value = 3.0
        self.speed_slider_small.value = 1.0
        def on_speed(s):
            val = max(0.05, float(s.value))
            self.speed_val_lbl.text = '{:.2f}x'.format(val)
            if self.cb_update_speed:
                self.cb_update_speed(val)
        self.speed_slider_small.action = on_speed
        hud.add_subview(self.speed_slider_small)
        y += 28

        # row 3: Damping + Trail
        lbl_damp = ui.Label(frame=(8,y,60,22))
        lbl_damp.text = 'Dämpf.'
        lbl_damp.font = ('<System>', 12)
        hud.add_subview(lbl_damp)

        self.damp_val_lbl = ui.Label(frame=(268,y,44,22))
        self.damp_val_lbl.alignment = ui.ALIGN_RIGHT
        self.damp_val_lbl.font = ('<System>', 12)
        self.damp_val_lbl.text = '0.00'
        hud.add_subview(self.damp_val_lbl)

        self.damp_slider = ui.Slider(frame=(66,y,198,22))
        self.damp_slider.minimum_value = 0.0
        self.damp_slider.maximum_value = 0.1
        self.damp_slider.value = 0.0
        def on_damp(s):
            val = max(0.0, float(s.value))
            self.damp_val_lbl.text = '{:.2f}'.format(val)
            if self.cb_update_damping:
                self.cb_update_damping(val)
        self.damp_slider.action = on_damp
        hud.add_subview(self.damp_slider)
        y += 28

        self.trail_switch = ui.Switch(frame=(66,y,56,28))
        self.trail_switch.value = True
        self.trail_switch.action = lambda s: self.cb_toggle_trail and self.cb_toggle_trail(bool(s.value))
        hud.add_subview(self.trail_switch)

        lbl_trail = ui.Label(frame=(8,y,56,22))
        lbl_trail.text = 'Trail'
        lbl_trail.font = ('<System>', 12)
        hud.add_subview(lbl_trail)

        btn_clear = ui.Button(frame=(132,y,80,28))
        btn_clear.title = 'Clear'
        btn_clear.action = lambda s: self.cb_clear_trail and self.cb_clear_trail()
        hud.add_subview(btn_clear)

        self.add_subview(hud)
        self.hud = hud

    def set_playing(self, playing):
        self.btn_play.title = 'Pause' if playing else 'Start'

    def draw(self):
        # drawing callback
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15  # pivot near top
        origin = (cx, cy)

        # background
        ui.set_color((0.98,0.98,0.98))
        ui.Path.rect(0,0,r.w,r.h).fill()

        # compute bob positions from model state
        th1, w1, th2, w2 = self.model.state
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter

        x1, y1 = polar_to_xy(origin, th1, l1)
        x2, y2 = polar_to_xy((x1,y1), th2, l2)

        # draw trails (for second bob)
        if self.trail:
            path = ui.Path()
            path.move_to(self.trail[0][0], self.trail[0][1])
            for (tx,ty) in self.trail[1:]:
                path.line_to(tx,ty)
            # stroke with fading alpha by drawing many segments? simple: constant alpha
            ui.set_color((0,0,0,0.15))
            path.stroke()

        # rods
        ui.set_color('black')
        p = ui.Path()
        p.move_to(origin[0], origin[1])
        p.line_to(x1, y1)
        p.stroke()
        p2 = ui.Path()
        p2.move_to(x1, y1)
        p2.line_to(x2, y2)
        p2.stroke()

        # bobs
        r1 = 14
        r2 = 12
        ui.set_color('gray')
        ui.Path.oval(x1-r1, y1-r1, r1*2, r1*2).fill()
        ui.set_color('darkred')
        ui.Path.oval(x2-r2, y2-r2, r2*2, r2*2).fill()

        # show pivot
        ui.set_color('black')
        ui.Path.oval(origin[0]-4, origin[1]-4, 8, 8).fill()

        # draw stamps
        ui.set_color('blue')
        for s in self.stamps:
            ui.Path.oval(s['x']-5, s['y']-5, 10, 10).fill()
            draw_text_at(s['text'], s['x']+8, s['y']-8, font=('Helvetica', 12))

        # overlay time
        ui.set_color('black')
        tlabel = 't = {:.3f} s'.format(self.model.sim_time)
        draw_text_at(tlabel, 8, r.h - 28, font=('Helvetica', 16))

    # Touch handling: allow dragging of first or second bob to set start angles
    def touch_began(self, touch):
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        th1, w1, th2, w2 = self.model.state
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter
        x1, y1 = polar_to_xy(origin, th1, l1)
        x2, y2 = polar_to_xy((x1,y1), th2, l2)

        tx, ty = touch.location
        if (tx-x2)**2 + (ty-y2)**2 < 20*20:
            self.dragging = 'bob2'
        elif (tx-x1)**2 + (ty-y1)**2 < 20*20:
            self.dragging = 'bob1'
        else:
            self.dragging = None
            self._tap_candidate = True
            try:
                self._tap_start = touch.timestamp
            except Exception:
                self._tap_start = time.time()

    def touch_moved(self, touch):
        if not self.dragging:
            # if finger moves too far, cancel tap candidate
            try:
                px, py = touch.prev_location
            except Exception:
                px, py = touch.location
            dx = touch.location[0] - px
            dy = touch.location[1] - py
            if dx*dx + dy*dy > 36:
                self._tap_candidate = False
            return
        r = self.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        tx, ty = touch.location

        if self.dragging == 'bob1':
            # set th1 from origin->touch
            th1 = xy_to_angle(origin, (tx,ty))
            # update state angles, zero velocities
            self.model.state[0] = th1
            self.model.state[1] = 0.0
            # also update second bob position to keep geometry (keep current th2)
            self.set_needs_display()
        elif self.dragging == 'bob2':
            # compute angle of second relative to first bob's position
            th1 = self.model.state[0]
            l1 = self.model.params['l1'] * self.model.pixels_per_meter
            x1, y1 = polar_to_xy(origin, th1, l1)
            th2 = xy_to_angle((x1,y1), (tx,ty))
            self.model.state[2] = th2
            self.model.state[3] = 0.0
            self.set_needs_display()

    def touch_ended(self, touch):
        if self.dragging:
            self.dragging = None
            return
        # toggle play/pause on simple tap
        if self._tap_candidate:
            self._tap_candidate = False
            if self.cb_toggle:
                self.cb_toggle(self)
        self.dragging = None

    # hooks from controller
    def attach_callbacks(self, *, on_toggle, on_reset, on_change_mode, on_speed, on_damping, on_toggle_trail, on_clear_trail):
        self.cb_toggle = on_toggle
        self.cb_reset = on_reset
        self.cb_change_mode = on_change_mode
        self.cb_update_speed = on_speed
        self.cb_update_damping = on_damping
        self.cb_toggle_trail = on_toggle_trail
        self.cb_clear_trail = on_clear_trail

        # sync HUD initial values
        self.speed_slider_small.value = getattr(self, 'speed_slider_small', self.speed_slider_small).value
        self.speed_val_lbl.text = '{:.2f}x'.format(1.0)
        self.damp_slider.value = 0.0
        self.damp_val_lbl.text = '0.00'

# ---------- Model (zustand + simulation-loop) ------------------

class PendulumModel(object):
    def __init__(self):
        # physical parameters (SI units)
        self.params = {
            'm1': 1.0,
            'm2': 1.0,
            'l1': 1.0,   # meters
            'l2': 1.0,
            'g': 9.81,
            'damping': 0.0
        }
        # initial state: theta measured from vertical (downwards)
        self.state = [math.radians(120), 0.0, math.radians(-10), 0.0]
        self.sim_time = 0.0
        self.running = False
        self.time_scale = 1.0  # speed multiplier
        self.dt = 0.01  # base timestep for integrator
        self.pixels_per_meter = 180.0  # scaling for drawing
        self.trail_max = 400
        self.trail = []
        self.trail_enabled = True
        self.stop_at = None  # if set, simulation will stop at this sim_time

    def step(self, dt):
        # advance by dt (already includes time_scale externally)
        self.state = rk4_step(self.state, dt, self.params)
        self.sim_time += dt

    def reset(self):
        self.state = [math.radians(120), 0.0, math.radians(-10), 0.0]
        self.sim_time = 0.0
        self.trail = []
        self.stop_at = None

    def single_step_silent(self, t):
        # compute state at time t from initial state (used for stamping positions at specific times)
        # integrate from t0=0 to t in a local copy so we don't disturb running sim
        s = [math.radians(120), 0.0, math.radians(-10), 0.0]
        params = self.params.copy()
        dt = 0.005
        steps = max(1, int(abs(t) / dt))
        dt = t / steps
        for i in range(steps):
            s = rk4_step(s, dt, params)
        return s

# ---------- Controller / App ----------------------------------

class PendulumApp(object):
    def __init__(self):
        self.model = PendulumModel()
        # root view with responsive layout
        self.view = ui.View()
        self.view.name = 'Doppelpendel — Demo'
        self.view.background_color = 'white'
        self.setup_layout()
        self.running = False
        # periodic timer
        self.timer = None

    def setup_layout(self):
        # left: drawing view
        self.draw_view = PendulumView(self.model)
        self.draw_view.frame = (0, 0, 700, 700)
        self.draw_view.flex = 'WH'
        self.view.add_subview(self.draw_view)

        # right: controls
        w = 300
        ctrl = ui.View(frame=(700,0,w,700))
        ctrl.flex = 'WH'
        ctrl.background_color = (0.96,0.96,0.96)

        y = 12
        def add_label(text):
            nonlocal y
            lbl = ui.Label(frame=(10,y, w-20, 26))
            lbl.text = text
            lbl.font = ('<System>', 14)
            lbl.flex = 'W'
            ctrl.add_subview(lbl)
            y += 30
            return lbl

        add_label('Controls')

        # Start/Pause Button
        self.btn_run = ui.Button(frame=(10,y, w-20, 40))
        self.btn_run.title = 'Start'
        self.btn_run.action = self.toggle_run
        self.btn_run.flex = 'W'
        ctrl.add_subview(self.btn_run)
        y += 48

        # Reset
        btn_reset = ui.Button(frame=(10,y, w-20, 34))
        btn_reset.title = 'Reset'
        btn_reset.action = lambda sender: self.reset()
        btn_reset.flex = 'W'
        ctrl.add_subview(btn_reset)
        y += 42

        # Mode (single/double)
        self.mode_seg = ui.SegmentedControl(frame=(10,y, w-20, 34))
        self.mode_seg.segments = ['Double','Single']
        self.mode_seg.selected_index = 0
        self.mode_seg.action = self.change_mode
        self.mode_seg.flex = 'W'
        ctrl.add_subview(self.mode_seg)
        y += 42

        # Speed slider
        add_label('Zeit-Skalierung (Speed)')
        self.speed_slider = ui.Slider(frame=(10,y, w-20, 34))
        self.speed_slider.minimum_value = 0.05
        self.speed_slider.maximum_value = 3.0
        self.speed_slider.value = 1.0
        self.speed_slider.action = lambda s: self.update_speed_value(float(s.value))
        self.speed_slider.flex = 'W'
        ctrl.add_subview(self.speed_slider)
        y += 42

        # Damping slider
        add_label('Dämpfung')
        self.damping_slider = ui.Slider(frame=(10,y, w-20, 34))
        self.damping_slider.minimum_value = 0.0
        self.damping_slider.maximum_value = 0.1
        self.damping_slider.value = 0.0
        self.damping_slider.action = lambda s: self.update_damping(float(s.value))
        self.damping_slider.flex = 'W'
        ctrl.add_subview(self.damping_slider)
        y += 42

        # Trail toggle + clear
        add_label('Spur aktiv')
        sw = ui.Switch(frame=(10,y, 54, 34))
        sw.value = True
        sw.action = lambda s: self.toggle_trail(bool(s.value))
        ctrl.add_subview(sw)
        btn_clear = ui.Button(frame=(80,y, w-90, 34))
        btn_clear.title = 'Spur löschen'
        btn_clear.action = lambda s: self.clear_trail()
        btn_clear.flex = 'W'
        ctrl.add_subview(btn_clear)
        y += 42

        # Trail length
        add_label('Spur-Länge')
        self.trail_slider = ui.Slider(frame=(10,y, w-20, 34))
        self.trail_slider.value = 400
        self.trail_slider.minimum_value = 10
        self.trail_slider.maximum_value = 1200
        self.trail_slider.action = self.update_trail
        self.trail_slider.flex = 'W'
        ctrl.add_subview(self.trail_slider)
        y += 42

        # Stop at time
        add_label('Automatisch stoppen bei t (s)')
        self.stop_field = ui.TextField(frame=(10,y, w-120, 34))
        self.stop_field.placeholder = 'z.B. 12.5'
        self.stop_field.flex = 'W'
        ctrl.add_subview(self.stop_field)
        btn_setstop = ui.Button(frame=(w-100,y,90,34))
        btn_setstop.title = 'Set Stop'
        btn_setstop.action = self.set_stop_time
        btn_setstop.flex = 'L'
        ctrl.add_subview(btn_setstop)
        y += 42

        # Compute pos at time
        add_label('Position berechnen bei t (s)')
        self.compute_field = ui.TextField(frame=(10,y, w-120, 34))
        self.compute_field.placeholder = 'z.B. 3.14'
        self.compute_field.flex = 'W'
        ctrl.add_subview(self.compute_field)
        btn_comp = ui.Button(frame=(w-100,y,90,34))
        btn_comp.title = 'Compute'
        btn_comp.action = self.compute_and_stamp
        btn_comp.flex = 'L'
        ctrl.add_subview(btn_comp)
        y += 42

        # Stamps list (short)
        add_label('Stamps (letzte)')
        self.stamps_label = ui.TextView(frame=(10,y, w-20, 140))
        self.stamps_label.editable = False
        self.stamps_label.flex = 'WH'
        ctrl.add_subview(self.stamps_label)
        y += 148

        self.view.add_subview(ctrl)
        self.ctrl = ctrl

        # connect HUD callbacks to controller methods
        self.draw_view.attach_callbacks(
            on_toggle=self.toggle_run,
            on_reset=lambda s: self.reset(),
            on_change_mode=self.change_mode,
            on_speed=self.update_speed_value,
            on_damping=self.update_damping,
            on_toggle_trail=self.toggle_trail,
            on_clear_trail=self.clear_trail,
        )

        # ensure initial layout fits the screen
        self.view.layout = self._layout_root
        self._layout_root()

    # Control callbacks
    def toggle_run(self, sender):
        if self.model.running:
            self.pause()
        else:
            self.start()

    def start(self):
        if self.model.running:
            return
        self.model.running = True
        self.btn_run.title = 'Pause'
        self._start_timer()
        self.draw_view.set_playing(True)

    def pause(self):
        self.model.running = False
        self.btn_run.title = 'Start'
        self._stop_timer()
        self.draw_view.set_playing(False)

    def reset(self):
        self.model.reset()
        self.draw_view.trail = []
        self.draw_view.stamps = []
        self.stamps_label.text = ''
        self.draw_view.set_needs_display()

    def change_mode(self, sender):
        if sender.selected_index == 1:
            # single pendulum -> set m2=0 to reduce to single pendulum
            self.model.params['m2'] = 0.0
        else:
            self.model.params['m2'] = 1.0

    def update_speed_value(self, val):
        self.model.time_scale = max(0.05, float(val))

    def update_trail(self, sender):
        self.model.trail_max = int(sender.value)

    def update_damping(self, val):
        self.model.params['damping'] = max(0.0, float(val))

    def toggle_trail(self, enabled):
        self.model.trail_enabled = bool(enabled)
        if not enabled:
            self.clear_trail()

    def clear_trail(self):
        self.draw_view.trail = []
        self.draw_view.set_needs_display()

    def set_stop_time(self, sender):
        try:
            v = float(self.stop_field.text)
            if v <= 0:
                self.model.stop_at = None
            else:
                self.model.stop_at = v
        except Exception:
            self.model.stop_at = None

    def compute_and_stamp(self, sender):
        # compute state at given time (from initial state) and stamp on the scene
        try:
            t = float(self.compute_field.text)
        except Exception:
            return
        s = self.model.single_step_silent(t)
        # convert to pixel coordinates
        r = self.draw_view.bounds
        cx = r.w * 0.5
        cy = r.h * 0.15
        origin = (cx, cy)
        l1 = self.model.params['l1'] * self.model.pixels_per_meter
        l2 = self.model.params['l2'] * self.model.pixels_per_meter
        x1, y1 = polar_to_xy(origin, s[0], l1)
        x2, y2 = polar_to_xy((x1,y1), s[2], l2)
        text = 't={:.3f}s\n({:.4f},{:.4f})'.format(t, x2/self.model.pixels_per_meter, y2/self.model.pixels_per_meter)
        # add stamp
        stamp = {'x': x2, 'y': y2, 'text': text}
        self.draw_view.stamps.append(stamp)
        # update textual stamps
        prev = self.stamps_label.text
        entry = 't={:.3f}s -> x={:.4f} m, y={:.4f} m\n'.format(t, x2/self.model.pixels_per_meter, y2/self.model.pixels_per_meter)
        self.stamps_label.text = entry + prev
        self.draw_view.set_needs_display()

    # Timer management
    def _start_timer(self):
        # run update loop in background thread to not block UI
        if self.timer:
            return
        self._timer_stop = False
        def loop():
            last = time.time()
            while self.model.running and not self._timer_stop:
                now = time.time()
                real_dt = now - last
                last = now
                # scaled dt
                dt = real_dt * self.model.time_scale
                # clamp dt so integrator remains stable
                steps = max(1, int(dt / self.model.dt))
                small_dt = dt / steps
                for i in range(steps):
                    self.model.step(small_dt)
                # update trail with second bob position
                r = self.draw_view.bounds
                cx = r.w * 0.5
                cy = r.h * 0.15
                origin = (cx, cy)
                l1 = self.model.params['l1'] * self.model.pixels_per_meter
                l2 = self.model.params['l2'] * self.model.pixels_per_meter
                x1, y1 = polar_to_xy(origin, self.model.state[0], l1)
                x2, y2 = polar_to_xy((x1,y1), self.model.state[2], l2)
                if self.model.trail_enabled:
                    self.draw_view.trail.append((x2,y2))
                    if len(self.draw_view.trail) > self.model.trail_max:
                        self.draw_view.trail.pop(0)
                    # copy trail to view for drawing
                    self.draw_view.trail = list(self.draw_view.trail)

                # check stop condition
                if self.model.stop_at is not None and self.model.sim_time >= self.model.stop_at:
                    # automatically pause
                    self.pause()
                    break

                # request redraw on main thread
                ui.delay(self.draw_view.set_needs_display, 0)
                # sleep a small amount
                time.sleep(0.016)  # ~60 Hz
        t = threading.Thread(target=loop)
        t.daemon = True
        t.start()
        self.timer = t

    def _stop_timer(self):
        self._timer_stop = True
        self.timer = None

    def present(self):
        # present the assembled UI
        self.view.present('fullscreen', hide_title_bar=True)

    # responsive layout for root view
    def _layout_root(self, *args, **kwargs):
        r = self.view.bounds
        total_w = r.w
        total_h = r.h
        ctrl_w = 320
        spacing = 0
        if total_w >= 980:
            # two columns
            self.draw_view.frame = (0, 0, total_w - ctrl_w - spacing, total_h)
            self.ctrl.frame = (total_w - ctrl_w, 0, ctrl_w, total_h)
        else:
            # stacked, controls below
            ctrl_h = min(360, total_h * 0.42)
            self.draw_view.frame = (0, 0, total_w, total_h - ctrl_h - spacing)
            self.ctrl.frame = (0, total_h - ctrl_h, total_w, ctrl_h)


# Run the app
if __name__ == '__main__':
    app = PendulumApp()
    app.present()
